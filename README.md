# NodeApp

Use NodeApp to write desktop apps in a mix of Node.js and native code.

The native (“frontend”) code handles the view part of MVC, while the Node.js (“backend”) code handles the controller and model parts. Uses native Cocoa on a Mac, and planning to use Qt on Windows and Linux.


NodeApp contains:

* an RPC library to communicate between the native and Node.js sides via JSON messages — if you ever used postMessage or modern browser extensions API, you should be familiar with the style;

* a native ‘core’ that initializes the app and transfers control to the RPC library to launch the backend and start processing its requests;

* a few optional native modules that add certain RPC endpoints (UI Elements library, FS monitoring, native preferences access, license management);

* a reactive depedency tracking library for the Node side;

* a UI Elements architecture that drives the binding between the native controls and the Node controllers (implemented as a module on the native side and as a library on Node side).

Also see [this gist](https://gist.github.com/2506111).



## Status

NodeApp is my cross-platform strategy for the [LiveReload app](http://livereload.com/). It is a work in progress and will mature together with LiveReload 3, due to be released in summer 2012.

Currently NodeApp lives in the [nodeapp folder of the LiveReload repository](https://github.com/livereload/LiveReload2/tree/nodejs/nodeapp). There are no skeleton apps provided yet. As soon as the framework is remotely ready for outside consumption, I will extract it into a separate repository.


## RPC

    core/nodeapp.h
    core/nodeapp_private.h
    core/nodeapp_rpc_*.h
    core/nodeapp_rpc_*.c
    core/{mac,win}/nodeapp_rpc_osdep.c

Starts up, runs, talks to and monitors the backend. Currently the Node.js code runs in a separate process and speaks JSON on stdin/stdout; in the future I might try to embed Node.js as a separate thread of the main process.

(I do love being able to run the backend manually from the command line, feed some JSON into it and get responses in return. That feels like the Unix way, so I don't think I will ever give up this ability completely.)

Status: The previous version of this code powers the currently shipping versions of LiveReload on Mac and Windows platforms, so it is known to work well. The code has been reorganized to be a part of NodeApp, though, and the new version has only been used for development so far.

There's nothing terribly specific to Node.js here, by the way; the native side of NodeApp would happily talk to Python or Ruby backends just as well, if someone writes the code to receive and send the same JSON payloads on stdin/stdout.



## Starting a NodeApp project

You need to have Ruby and Node.js installed. Ruby 1.8.7 which comes with OS X works fine; haven't tried with Ruby 1.9. Tested with Node 1.6; won't work with 1.4, might work with later versions.

Here's the recipe for a project:

* Make a copy of the skeleton app

* Customize `app_config.h` (provided by the skeleton app)

* Set the current version number in `mac/Info.plist` and run `rake ver:mac:update` to update the version number everywhere (currently the only other copy is in `app_version.h`, see the definition of `MacVersion` in the Rakefile)

* Run `rake prepare` to install all prerequisites and compile the backend

* Run `rake routing` to generate `shared/gen_src/nodeapp_rpc_proxy.h`, `shared/gen_src/nodeapp_rpc_proxy.c` (which provide function stubs for all RPC endpoints exposed by the Node app) and `shared/gen_src/nodeapp_rpc_router.c` (which routes the incoming RPC requests to their respective native implementations). This task starts up the backend to query the list of RPC endpoints, so it will fail if the backend fails to run.

* Open `mac/YourProject.xcodeproj` in Xcode, build and run. (Qt part will have something similar.)

* Write your app (see a section on that below)

* Shake well

* Distribute


## What goes where

* `shared/src`: native sources shared between the platforms (`app_config.h` lives here)

* `shared/gen_src`: files generated by `rake routing`

* `{mac/win}/src/app_version.h`: version number is defined here (could be different across the platforms)

* `{mac,win}/src/vendor`: third-party libraries, fragments of Apple/MSDN examples and code snippets hunted down on StackOverflow

* `mac/src/ui`: your xibs and NSWindowController descendants

* `mac/src/app/AppDelegate.m`: lifecycle events of your app, if you need to run some custom code

* `mac/src/main.m`: execution actually starts here

* `mac/Info.plist`: defines everything Apple and OS X want to know about your app

* `mac/App.icns`: your icon

* `mac/MainMenu.xib`: duh, define your menu structure here


## Writing an app

* start with a skeleton app as described above

* build your views layer using the native techologies: create an empty NSWindowController subclass for each window, design the xib in Interface Builder; not exactly sure about the Qt part yet — I'm thinking about auto-converting xibs into Qt UIs

* build your controllers layer in Node.js using the UI Elements and (optionally) the reactive dependency tracking

* build your model layer in Node.js, optionally using the reactive dependency tracking library

* add the necessary bits of native code to handle stuff that you cannot or do not want to do in JavaScript
